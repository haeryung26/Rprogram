---
title: "Chapter 2. 워크플로 기초, 3. 데이터 변형"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Chapter2
### 코딩기초 및 이름에 들어갈 것

- R은 기본적으로 계산기로 사용 가능

```{r}
1 / 200 * 30
(59 + 73 + 2) / 3
sin(pi/2)

```

- 객체를 생성하는 모든 R 명령어, 즉 할당문은 "객체이름<- 값" 의 형식을 갖음
- 객체 이름이 값을 갖음 (object name gets value)
- "<-" 를 사용하는 것이 고통스러울 수 있지만 귀찮다고 =을 사용하지 말아야 함. 작동은 하지만 나중에 혼란스러울 수 있음
- 객체 이름은 문자로 시작해야 하고 문자, 숫자, _, .만 포함해야 함.


```{r}
x <- 3 * 4; print(x)
this_is_a_really_long_name <- 2.5
print(this_is_a_really_long_name)
```

- R은 대소문자를 구별함

```{r}
r_rocks <- 2 ^ 3
#r_rock
#> Error: object 'r_rock' not found
#R_rocks
#> Error: object 'R_rocks' not found
```

### 함수 호출하기

- R은 기본적으로 내장 함수를 많이 포함함 (해당 패키지가 로딩되어 있을 시)
- 예를 들어, 숫자 시퀀스를 만드는 seq() 함수가 존재함. 해당 함수를 찾을 시 se를 타이핑하고 탭을 쳐서 화살표 키로 선택하여 seq()를 지정해서 사용하거나 F1 키를 눌러 하단 오른쪽 창의 헬프 탭에 있는 세부 내용 참고할 수 있음.
- 원하는 함수를 선택했을 때 탭을 한번 더 누르면 괄호 추가 가능함. 
- 할당문을 만들었다면 값을 바로 볼 수 없고, 호출해야 결과 확인 가능함. 

```{r}
seq(1, 10)
y <- seq(1, 10, length.out = 5); y

```


- 할당문을 괄호로 묶으면 됨. 할당되는 동시에 '스크린에 인쇄'됨 
```{r}
(yy <- seq(1, 10, length.out = 5))

```

# Chapter3
### 데이터 변형

* 데이터를 좀 더 쉽게 사용할 수 있도록 새로운 변수나 요약값을 만들어야 할 수도 있고, 변수 이름을 변경하거나 관측값들을 재정렬해야 하는 경우에 사용. **dplyr 패키지 데이터 작업(manipulation) 동사 탐색을 위해 사용함.**
* flights 데이터셋 (nycflights13 패키지 내장) 2013년 뉴욕시 출발 항공편에 대한 336,776개의 항공편이 포함된 셋임.

```{r}
library(nycflights13)
library(tidyverse)
library(dplyr)
library(ggplot2)
flights
```

### 데이터 변형

* 데이터를 좀 더 쉽게 사용할 수 있도록 새로운 변수나 요약값을 만들어야 할 수도 있고, 변수 이름을 변경하거나 관측값들을 재정렬해야 하는 경우에 사용. **dplyr 패키지 데이터 작업(manipulation) 동사 탐색을 위해 사용함.**
* flights 데이터셋 (nycflights13 패키지 내장) 2013년 뉴욕시 출발 항공편에 대한 336,776개의 항공편이 포함된 셋임.

```{r}
library(nycflights13)
library(tidyverse)
library(dplyr)
flights
```

**int는 정수; dbl은 더블형, 또는 실수; chr은 문자형 벡터, 혹은 문자열; dttm은 데이트-타임형(날짜+시간)을 의미**

## dplyr 기초

* 값을 기준으로 선택 (Pick observations by their values; filter()).
* 행을 재정렬 (Reorder the rows; arrange()).
* 이름으로 변수 선택 (Pick variables by their names; select()).
* 기존 변수의 함수로 새로운 변수 생성 (Create new variables with functions of existing variables; mutate()).
* 하나의 요약값으로 합침 (Collapse many values down to a single summary; summarise()).
* **위의 함수들은 모두 group_by()와 함께 사용**할 수 있음. 

## filter() 로 행 필터링하기 

* filter()를 이용하면 값을 기준으로 데이터를 서브셋(subset) 할 수 있음. 
* 1번째 인수는 dataframe 이름이고, 2번째 인수는 dataframe 필터링하는 표현식임. 
* 12월 25일의 뉴욕시 출발 항공편에 대한 결과를 filter() 를 통해 생성

```{r}
(dec25 <- filter(flights, month == 12, day == 25))
```

#### 비교 연산
* filter() 를 효과적 사용하려면 비교 연산자를 사용하여 원하는 관측값을 선택할 수 있어야 함
* **>, >=, <, <=, != (not equal), and == (equal)** (특히, equal에 대해 = 대신 ==를 사용해야함)

#### 논리 연산
* & 는 “and”, | 는 “or”, 그리고 ! 는 “not”.
![Boolean figure](figure.JPG)
* 11월이나 12월에 출발한 항공편 모두를 찾으려면 아래와 같은 코드 사용.

```{r}
filter(flights, month == 11 | month == 12)
```

* 또는 **'x %in% y'** (여러개의 값을 선택할 때 훨씬 효율적) 를 사용하여 x가 y에 있는 값 중 하나인 행을 모두 선택

```{r}
nov_dec <- filter(flights, month %in% c(11, 12))
nov_dec
```


* 두 시간 이상 지연되지 않은 항공편을 모두 찾고 싶다면, 아래의 필터 중 하나를 선택 가능

```{r}
filter(flights, !(arr_delay > 120 | dep_delay > 120))
filter(flights, arr_delay <= 120, dep_delay <= 120)
```


#### 결측값
* NA는 모르는 값이므로 결측값은 파급(contagious). 즉, 모르는 값이 연관된 연산의 결과도 대부분 모르는 값임임

```{r}
NA > 5
#> [1] NA
NA + 10
#> [1] NA
NA / 2
#> [1] NA
```

* 값이 결측인지 확인하고 싶다면? **is.na()**

```{r}
x <- NA
is.na(x)
#> [1] TRUE
```


* filter()는 조건이 TRUE인 열만 포함. FALSE, NA 제외하는 것이 일반적임

```{r}
df <- tibble(x = c(1, NA, 3))
filter(df, x > 1)
filter(df, is.na(x) | x > 1)
```

## arrange() 로 행 정렬하기 

* arrange()는 행을 선택하는 대신, 순서를 바꾼다는 것만 제외하고 filter()와 유사하게 작동
* dataframe과 정렬기준으로 지정할 열 이름 집합을 입력으로 함
* 하나 이상 열 이름 제공 시 동점값(tie) 상황을 해결하는 데 사용됨
* desc()를 사용하면 내림차순으로 열이 재정렬됨 (default는 오름차순)

```{r}
arrange(flights, desc(dep_delay))
```

* 결측값은 항상 마지막에 정렬됨

```{r}
df <- tibble(x = c(5, 2, NA))
arrange(df, x)
arrange(df, desc(x))
```


## select()로 열 선택하기

* select()와 변수 이름 기반한 연산을 이용하면 서브셋(subset)으로 신속하게 줌인(zoom in). 

```{r}
# Select columns by name (이름으로 열 선택)
select(flights, year, month, day)
select(flights, year:day)
select(flights, -(year:day))
```

* **starts_with("abc")**: “abc”로 시작하는 이름에 매칭
* **ends_with("xyz")**: “xyz”로 끝나는 이름에 매칭칭
* **contains("ijk")**: “ijk”를 포함하는 이름에 매칭칭
* **matches("(.)\\1")**: 정규표현식에 매칭되는 변수들을 선택. 이 표현식은 반복되는 문자를 포함하는 변수에 매칭됨 (11장에 자세하게 다룰 예정)
* **num_range("x", 1:3)**: matches x1, x2 and x3

## mutate()로 새로운 변수 추가하기

* flights_sml 셋을 생성 후 참조하여 추가 연산 가능

```{r}
flights_sml <- select(flights, 
  year:day, 
  ends_with("delay"), 
  distance, 
  air_time
)
mutate(flights_sml,
  gain = dep_delay - arr_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)
```

* 새 변수만 남기고 싶다면 transmute() 사용

```{r}
transmute(flights,
  gain = dep_delay - arr_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)
```

* 산술 연산자(Arithmetic operators): **+, -, *, /, ^**  (e.g. air_time/60, hours*60 + minute 등)
* 모듈러 연산(Modular arithmetic; 많이 사용되지는 않음): %/% (정수 나누기) and %% (나머지). 예를들어 항공편 데이터셋의 dep_time으로부터 hour와 minute을 다음과 같이 계산 가능
```{r}
transmute(flights,
  dep_time,
  hour = dep_time %/% 100,
  minute = dep_time %% 100
)
```

* logs: log(), log2(), log10() 등임. 로그는 여러 차수를 넘나드는 데이터를 처리하는 데 매우 유용한 변환. 다른 조건이 같다면 log2() 사용을 추천하는데, 해석이 쉽기 때문임 (로그 스케일에서 1 차이는 원 스케일에서 두 배에 해당되고 -1 차이는 절반에 해당됨) 
* Offsets: lead(), lag()를 사용하면 벡터를 앞으로 당기거나 (leading), 뒤로 미는(lagging) 것을 참조 가능. **연속된 차이값(differences)을 계산하거나 (예: x-lag(x)) 값들이 변경된 곳을 찾는 데 (x !=lag(x)) 사용할 수 있으며, group_by()와 함께 사용할 때 유용하게 사용됨**

```{r}
(x <- 1:10)
lag(x)
lead(x)
```


* 누적 및 롤링 집계: 누적합-cumsum(), 누적곱-cumprod(), 누적평균-cummean()

```{r}
cumsum(x)
cummean(x) # meaning?
```
* 논리형 비교 연산자: <, <=, >, >=, !=, ==

## summarize()로 그룹화 요약하기
* dataframe을 하나의 행으로 축약. 주로 group_by()와 함께 사용. group_by()는 분석 단위의 전체 데이터셋에서 개별 그룹으로 변경함. 
* 예를들어, 날짜로 그룹화된 dataframe에 코드 적용하면 *날짜별 평균 지연시간*이 계산됨됨
* na.rm = TRUE는 na가 발생하면 제거하라는 것으로 계산전에 결측값을 제거 가능능

```{r}
by_day <- group_by(flights, year, month, day)
summarise(by_day, delay = mean(dep_delay, na.rm = TRUE))

```

#### 파이프 (%>%)로 여러 작업 결합하기
* 각 위치에 대해 거리와 평균 지연 사이의 관계를 탐색한 후 그래프로 표현하면?
  * **파이프(%>%) 의미는 '그 다음'**으로 읽을 수 있음. 
* 파이프를 사용하여 다중 작업을 왼쪽에서 오른쪽으로, 위에서 아래로 읽을 수 있게 쓸 수 있음. 파이프를 사용하면 코드 가독성이 좋아지므로 많이 사용!!
  
```{r}
delays <- flights %>% 
  group_by(dest) %>% 
  summarise(
    count = n(),
    dist = mean(distance, na.rm = TRUE),
    delay = mean(arr_delay, na.rm = TRUE)
  ) %>% 
  filter(count > 20, dest != "HNL")
head(delays)

not_cancelled <- flights %>% 
  filter(!is.na(dep_delay), !is.na(arr_delay))

delays <- not_cancelled %>% 
  group_by(tailnum) %>% 
  summarise(
    delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )
```  
  

* 비행이 25건 이상일때의 평균 지연시간에 대한 그래프

```{r}
delays %>% 
  filter(n > 25) %>% 
  ggplot(mapping = aes(x = n, y = delay)) + 
  geom_point(alpha = 1/10)
```


#### 기타 유용한 요약함수
* 위치 측정값: mean(x), median(x) 

```{r}
not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(
    avg_delay1 = mean(arr_delay),
    avg_delay2 = mean(arr_delay[arr_delay > 0]) # the average positive delay
  )
```


* 산포 측정값: sd(x)는 standard deviation이고 산포의 표준 측정값. 중심으로 부터 표본값이 얼마나 떨어져 있는지에 대한 값을 의미함 (sqrt(variance)를 의미), IQR(x)는 사분위범위(interquantile range)를 의미하고, 전체적인 값의 분포를 확인하기 위해 사용가는 값임. mad(x)는 이상값이 있을 때 유용한 robust한 대체값임
```{r}
not_cancelled %>% 
  group_by(dest) %>% 
  summarise(distance_sd = sd(distance)) %>% 
  arrange(desc(distance_sd))
``` 


* 순위 측정값: min(x), quantile(x,0.25)는 25% 보다는 크고, 나머지는 75% 보다는 작은값을 찾음음
```{r}
not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(
    first = min(dep_time),
    last = max(dep_time)
  )
``` 

* 자리(position) 측정값: first(x), nth(x,2), last(x)
* 예를 들어 각 날짜에 처음과 마지막 출발을 찾을 경우에는 아래과 같이 작성 가능
```{r}
not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(
    first_dep = first(dep_time), 
    last_dep = last(dep_time)
  )
``` 


* 카운트: 결측이 아닌 값의 수를 카운트하려면 sum(!is.na(x))를 사용하면 되고 유일한 개수를 카운트 하려면 n_distinct(x)를 사용 
* 또한 단순히 카운트만 원할 경우 바로 count함수를 사용할 수 있음
```{r}
not_cancelled %>% 
  group_by(dest) %>% 
  summarise(carriers = n_distinct(carrier)) %>% 
  arrange(desc(carriers))

not_cancelled %>% count(dest)
``` 

#### 여러 변수로 그룹화
* 여러 변수로 그룹화하면 각 요약값은 그룹화의 한 수준씩 벗겨냄. 이를 이용하면 데이터셋을 점진적으로 쉽게 요약 가능함
```{r}
daily <- group_by(flights, year, month, day)
(per_day   <- summarise(daily, flights = n()))
``` 


#### FBMD 데이터 셋에 적용
* 여러 변수로 그룹화하면 각 요약값은 그룹화의 한 수준씩 벗겨냄. 이를 이용하면 데이터셋을 점진적으로 쉽게 요약 가능함
```{r}
(per_day   <- summarise(daily, flights = n()))
``` 


